#summary The format specification for CA rule table files
== Examples: ==

{{{
# Signals (2/3) pass alongside a wire (1):
n_states:4
neighborhood:vonNeumann
symmetries:rotate4
var a={2,3}
var b={2,3}
var c={2,3}
a,0,b,1,c,b
}}}

== Specification: ==

See the .table files in the Rules folder for more examples. Empty lines and those beginning with the hash symbol "#" are ignored.

Required descriptors (must appear before other content):

    * n_states: specifies the number of states in the CA (from 0 to n_states-1 inclusive).
    * neighborhood: specifies the cell neighborhood for the CA update step. Must be one of: vonNeumann, Moore.
    * symmetries: can be one of the following: none, rotate4, rotate8, reflect, rotate4reflect, rotate8reflect. Hopefully these are self-explanatory.

The rest of the file contains variables and transitions. Variable names should only use the letters a-z,A-Z (case-sensitive). Each variable line should follow the form above to list the states. Variables should appear before the first transition that uses them.

Transition lines should have states or variables separated by commas. If there are no variables and n_states<11 then no comma should be used. Only one transition (or variable) should appear on each line. Inputs are listed in the order C,N,E,S,W,C' for the von Neumann neighborhood, and C,N,NE,E,SE,S,SW,W,NW,C' for the Moore neighborhood.

Where the same variable appears more than once in a transition, it stands for the same state each time. A transition can have a variable as its output (C') but only where that variable appears more than once, so that it has a definite value. 

Therefore, the transition in the example above expands to the following: 
{{{
20212->2
20213->2
20312->3
20313->3
30212->2
30213->2
30312->3
30313->3
}}}

and all 90-degree rotations of those (because of the rotate4 symmetry).

Rule tables usually don't specify every possible set of inputs. For those not listed, the central cell remains unchanged.

Rules are checked in the order given in the file - the first rule that matches is applied. If you want, you can write rules in the form of general cases and exceptions, as long as the exceptions appear first in the file.

(This form of CA rule table representation comes from Gianluca Tempesti's PhD thesis: http://lslwww.epfl.ch/pages/embryonics/thesis/AppendixA.html.)

If you have a C/C++ implementation of a transition function, there is a way to automatically produce a rule table file. See make-ruletable.cpp for instructions. 

Golly has a page describing the format: [http://golly.cvs.sourceforge.net/viewvc/*checkout*/golly/golly/src/Help/formats.html#table .table format specification]

== About the development of the format: ==

(TJH wrote:)

There are other CA rule table formats out there. The simplest is just to list the transitions. Codd and Langton used this method, where e.g. 012345 stands for the transition:
<tt><pre>
     1 
   4 0 2    --->     5
     3
</pre></tt>
The inputs are given in the order: centre, north, east, south, west, followed by the updated centre state. For CA that only use states 0-9, no separator is required, so each transition is just a sequence of 6 digits. The .table format supports this, and also the Moore neighbourhood version: C,N,NE,E,SE,S,SW,W,NW,C'. For CA with more than 10 states, commas are used to separate the entries.

Rather than list every transition, we can skip transitions that make no change to C. We can also skip transitions that are rotated or reflected versions of ones already listed. (More on this later.)

However, for more complex CA, including von Neumann's original 29-state CA, this is not sufficient. Too many transitions would have to be listed. Most CA programs get around this by hard-coding the transition tables, as C++ or Java or whatever. This is fine and good but not future-proof. If someone gave you a stack of rules for your new CA engine you'd have to carefully translate each one into your desired language.

A different problem was encountered when considering some other rule table formats: [http://www.jcasim.de/ CDL], cellang (I've never seen any details but I think it's not dissimilar) and CAXL (likewise). CDL, for example, is an entire programming language, and adding support for this to your favourite CA program would be a significant amount of work. There has to be a simpler way to encode rule tables that is both reasonably compact and easy to understand and use, for the majority of popular CA rules. And there is!

The XLife program has the .r format, e.g. [http://www.filewatcher.com/p/xlife-5.0-1.i386.rpm.211831/usr/lib/xlife/codd/codd.r.html codd.r], where square brackets are used for multiple states. E.g. `0000[45]0` stands for the transitions <tt>0,0,0,0,4 -> 0</tt> and <tt>0,0,0,0,5 -> 0</tt>. This is a big leap forwards, allowing rule tables to be expressed in a reasonably compact form. The problem is that it doesn't provide enough compression.

The adopted solution can be found in Gianluca Tempesti's [http://lslwww.epfl.ch/pages/embryonics/thesis/AppendixA.html thesis] - using variables to stand for multiple states. Then, e.g. for a={1,2,3}, the rule <tt>1,a,3 -> a</tt> would stand for three rules at once: <tt>1,1,3 -> 1</tt> and <tt>1,2,3 -> 2</tt> and <tt>1,3,3 -> 3</tt>. This method gives all the compression of the XLife approach and then some more on top.
