=1=
Have several of items at the top of the .table file.

{{{
n_states: 20
grid: yes
space: euclidean
sides: 4
dimentions: 2
neighborhood: Moore
symmetries: rotate4
radius: 2
}}}

A neighbourhood could then be constructed without the need for too many differnt types.

  What is 'grid'?

CA's that line up nodes (cells) in a grid. In a practical sence this will always be "yes".

  How would non-Euclidean spaces be defined?

Hyperbolic space for example.

  What does 'sides' mean?

Most CA's use a 4 Sided grid but one in particular uses a 7 sided grid requiring hyperbolic rendering to draw it, there are also 6 sided hexagonal grids and 3 sided grids that work on standard space. 1D CA's are 2 sided grids.

  Also I can see several problems with this approach - it doesn't adapt to the partitioning neighborhoods very well, for example, and some of these headers won't make sense with some CA. The advantage of our current set of headers (n_states,neighborhood,symmetries) is that they apply to all possible CA, as far as we can tell.

The options in 'Neighborhood' depends on some of the others but other that that it is quite simple and consistant. Give me a CA that either in Golly or not yet avalible and I will tell you the set-up for it.

  Can you clarify your suggestion? -- TJH

I hope I have done so, if not please tell me.
=2=
Documenting parts of patterns by selecting rectangular groups of cells and applying text to them that apear after zooming in past a 1:1 zoom as a fixed size at a fixed or relative orentation to the box, like a label. The box itself could have thin or\and subtley coloured borders.

The text for them would be stored in the RLE or MC file.

Controll click drag to create, right click them choose delete from dropdown menu to remove (or similar). I know there are coding issues with how UI is drawn atm though.

  This suggestion isn't anything to do with rule table files though - you should seek support for this idea on the golly list, not here. Or implement it yourself so we can see an example of what you mean. -- TJH

I can't code it into Golly but do you want me to create a fake screenshot or two to show how it could work? List pointed me here.
=3=
I'm not sure if this is my method or an obvious algebraic method or even if it definitely works but here goes.

It's based on something similar I did for Minesweeper that did work, inspired by something I read online about suprisingly long distance behaviour in certain Minesweeper configuations.

Start with a simple example from WireWorld.
http://mathworld.wolfram.com/WireWorld.html

Lets say for simplicity:

{{{
000
133
000
}}}

According to the rules of WireWorld this will progress as so.

{{{
000
213
000
}}}

{{{
000
321
000
}}}

{{{
000
332
000
}}}

{{{
000
333
000
}}}

As the signal travels down the wire

First create (a map?) for each state that changes.

All

{{{
000
133
000
}}}

State 1

{{{
000
100
000
}}}

State 2

{{{
000
000
000
}}}

And assign letters to each cell in each map.

All

{{{
abc
def
ghi
}}}

State 1

{{{
rst
uvw
xyz
}}}

State 2

{{{
ABC
DEF
GHI
}}}


Construct the formuli.

{{{
a[0] = 0

...

I[0] = 0
}}}

Skip a to i for this next part.

{{{
r[n] = (0 < s[n-1] + u[n-1] + v[n-1] < 3)

...

I...
}}}

Now you can rearange the equation to ask questions like for example, does this cell ever become state 1 or what are all the possiblilites for the previous generation that could lead to this one.

And specifically code could be written into Golly to do this.

  I don't really understand your suggestion but either way there's nothing stopping you using this kind of notation in your own tools (e.g. python scripts) before compiling them down to rule tables or rule trees. We decided early on that we didn't want to support [http://www.jcasim.de/ CDL]-style expression languages - and so far we haven't been regretting that decision - even Wireworld is reasonably simple to read in the rule table format. -- TJH

I don't mean a fancy rule, I mean a way to perform other functions in Golly. For example you could request extra information about a cell. For example cell (100, 120) could currently be state 3, and it could be determined that after running the CA for an infinite length of time it would eventually become at some point state 4 and 6 but never states 0, 1, 2, 3 or 5.